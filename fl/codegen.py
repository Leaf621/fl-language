from fl.ast_nodes import (
    AdoptStatement, VariableDecl, Assignment, IfStatement, WhileStatement,
    ForEachStatement, ReturnStatement, ExpressionStatement, Block,
    NumberLiteral, StringLiteral, BoolLiteral, ArrayLiteral, Identifier,
    BinaryOp, UnaryOp, MemberAccess, ModuleAccess, IndexAccess,
    FunctionCall, Closure, Param, RangeExpr, MakeoutExpr, NativeBlock,
    ClassDef, Module, Program,
)
from fl.stdlib import is_stdlib, get_stdlib_js


class CodeGenError(Exception):
    pass


class CodeGen:
    def __init__(self):
        self.indent_level = 0
        self.indent_str = "    "
        self.output_lines: list[str] = []
        self.stdlib_used: set[str] = set()
        self.module_imports: list[AdoptStatement] = []
        self.in_class: str | None = None
        self.class_private_members: set[str] = set()
        self.class_shared_members: set[str] = set()

    def indent(self) -> str:
        return self.indent_str * self.indent_level

    def emit(self, line: str):
        self.output_lines.append(self.indent() + line)

    def emit_raw(self, line: str):
        self.output_lines.append(line)

    # === Program-level generation ===

    def generate_program(self, program: Program) -> str:
        """Generate JS for an entire program (multiple modules bundled)."""
        lines = []
        lines.append("// Generated by Femboy Language Compiler")
        lines.append("")

        # Collect all stdlib usage across modules
        for module in program.modules:
            for stmt in module.statements:
                if isinstance(stmt, AdoptStatement) and is_stdlib(stmt.module_path[0]):
                    self.stdlib_used.add(stmt.module_path[0])

        # Emit stdlib shims
        for mod_name in sorted(self.stdlib_used):
            js = get_stdlib_js(mod_name)
            if js:
                lines.append(js)
        if self.stdlib_used:
            lines.append("")

        # Emit non-main modules as IIFEs
        main_module = None
        for module in program.modules:
            if module.path == "__main__":
                main_module = module
            else:
                lines.append(self._generate_module_iife(module))
                lines.append("")

        # Build module namespace objects for the entry module
        if main_module:
            # Emit entry module (not a module IIFE â€” no __exports)
            gen = CodeGen()
            gen.stdlib_used = self.stdlib_used
            code = gen._generate_module_body(main_module, is_entry=False)
            lines.append(code)

        return "\n".join(lines)

    def generate_module(self, module: Module) -> str:
        """Generate JS for a single module (entry point)."""
        program = Program(modules=[module])
        # Scan for stdlib
        for stmt in module.statements:
            if isinstance(stmt, AdoptStatement) and is_stdlib(stmt.module_path[0]):
                self.stdlib_used.add(stmt.module_path[0])

        lines = []
        lines.append("// Generated by Femboy Language Compiler")
        lines.append("")

        for mod_name in sorted(self.stdlib_used):
            js = get_stdlib_js(mod_name)
            if js:
                lines.append(js)
        if self.stdlib_used:
            lines.append("")

        code = self._generate_module_body(module, is_entry=True)
        lines.append(code)
        return "\n".join(lines)

    def _generate_module_iife(self, module: Module) -> str:
        """Generate a module as an IIFE returning exports."""
        safe_name = module.path.replace('.', '$')
        gen = CodeGen()
        gen.stdlib_used = self.stdlib_used

        body_lines = []
        body_lines.append(f"const {safe_name} = (() => {{")
        body_lines.append(f"    const __exports = {{}};")

        gen.indent_level = 1
        gen.output_lines = []
        for stmt in module.statements:
            if isinstance(stmt, AdoptStatement):
                continue  # handled at top level
            gen.gen_statement(stmt, is_module=True)

        body_lines.extend(gen.output_lines)
        body_lines.append(f"    return __exports;")
        body_lines.append(f"}})();")
        return "\n".join(body_lines)

    def _generate_module_body(self, module: Module, is_entry: bool = False) -> str:
        """Generate module body statements."""
        self.output_lines = []
        self.indent_level = 0

        # Collect non-stdlib imports to set up namespace references
        user_imports = []
        for stmt in module.statements:
            if isinstance(stmt, AdoptStatement) and not is_stdlib(stmt.module_path[0]):
                user_imports.append(stmt)

        # Build namespace objects for user imports
        if user_imports:
            namespaces: dict[str, dict] = {}
            for imp in user_imports:
                path = imp.module_path
                safe_name = '.'.join(path).replace('.', '$')
                # Build nested namespace: localdir.localfile -> localdir = { localfile: ... }
                root = path[0]
                if root not in namespaces:
                    namespaces[root] = {}
                if len(path) > 1:
                    current = namespaces[root]
                    for part in path[1:-1]:
                        if part not in current:
                            current[part] = {}
                        current = current[part]
                    current[path[-1]] = safe_name

            for root, tree in namespaces.items():
                if isinstance(tree, str):
                    self.emit(f"const {root} = {tree};")
                elif tree:
                    js_obj = self._build_namespace_obj(tree)
                    self.emit(f"const {root} = {js_obj};")
                # Single-segment imports (e.g., adopt utils) need no namespace
                # binding â€” the IIFE already declares `const utils = ...`

        # Generate statements
        for stmt in module.statements:
            if isinstance(stmt, AdoptStatement):
                continue
            self.gen_statement(stmt, is_module=is_entry)

        return "\n".join(self.output_lines)

    def _build_namespace_obj(self, tree: dict) -> str:
        parts = []
        for key, val in tree.items():
            if isinstance(val, str):
                parts.append(f"{key}: {val}")
            elif isinstance(val, dict):
                parts.append(f"{key}: {self._build_namespace_obj(val)}")
        return "{ " + ", ".join(parts) + " }"

    # === Statement generation ===

    def gen_statement(self, stmt, is_module: bool = False):
        if isinstance(stmt, VariableDecl):
            self.gen_variable_decl(stmt, is_module)
        elif isinstance(stmt, Assignment):
            self.gen_assignment(stmt)
        elif isinstance(stmt, IfStatement):
            self.gen_if(stmt)
        elif isinstance(stmt, WhileStatement):
            self.gen_while(stmt)
        elif isinstance(stmt, ForEachStatement):
            self.gen_foreach(stmt)
        elif isinstance(stmt, ReturnStatement):
            self.gen_return(stmt)
        elif isinstance(stmt, ExpressionStatement):
            self.emit(f"{self.gen_expr(stmt.expr)};")
        elif isinstance(stmt, AdoptStatement):
            pass  # handled at module level
        else:
            raise CodeGenError(f"Unknown statement type: {type(stmt).__name__}")

    def gen_variable_decl(self, decl: VariableDecl, is_module: bool = False):
        if decl.value is not None:
            if isinstance(decl.value, ClassDef):
                self.gen_class(decl.name, decl.value, is_shared=decl.is_shared, is_module=is_module)
                return
            if isinstance(decl.value, Closure) and self.in_class:
                # This is handled by gen_class
                return
            val = self.gen_expr(decl.value)
            self.emit(f"let {decl.name} = {val};")
        else:
            self.emit(f"let {decl.name};")

        if decl.is_shared and is_module:
            self.emit(f"__exports.{decl.name} = {decl.name};")

    def gen_assignment(self, assign: Assignment):
        target = self.gen_expr(assign.target)
        value = self.gen_expr(assign.value)
        self.emit(f"{target} {assign.op} {value};")

    def gen_if(self, stmt: IfStatement):
        cond = self.gen_expr(stmt.condition)
        self.emit(f"if ({cond}) {{")
        self.indent_level += 1
        for s in stmt.body.statements:
            self.gen_statement(s)
        self.indent_level -= 1
        for elif_cond, elif_body in stmt.elif_clauses:
            c = self.gen_expr(elif_cond)
            self.emit(f"}} else if ({c}) {{")
            self.indent_level += 1
            for s in elif_body.statements:
                self.gen_statement(s)
            self.indent_level -= 1
        if stmt.else_body:
            self.emit("} else {")
            self.indent_level += 1
            for s in stmt.else_body.statements:
                self.gen_statement(s)
            self.indent_level -= 1
        self.emit("}")

    def gen_while(self, stmt: WhileStatement):
        cond = self.gen_expr(stmt.condition)
        self.emit(f"while ({cond}) {{")
        self.indent_level += 1
        for s in stmt.body.statements:
            self.gen_statement(s)
        self.indent_level -= 1
        self.emit("}")

    def gen_foreach(self, stmt: ForEachStatement):
        iterable = self.gen_expr(stmt.iterable)
        self.emit(f"for (const {stmt.var_name} of {iterable}) {{")
        self.indent_level += 1
        for s in stmt.body.statements:
            self.gen_statement(s)
        self.indent_level -= 1
        self.emit("}")

    def gen_return(self, stmt: ReturnStatement):
        if stmt.value:
            self.emit(f"return {self.gen_expr(stmt.value)};")
        else:
            self.emit("return;")

    # === Class generation ===

    def gen_class(self, name: str, cls: ClassDef, is_shared: bool = False,
                  is_module: bool = False):
        parent_clause = f" extends {cls.parent}" if cls.parent else ""
        self.emit(f"class {name}{parent_clause} {{")
        self.indent_level += 1

        old_class = self.in_class
        old_private = self.class_private_members
        old_shared = self.class_shared_members
        self.in_class = name
        self.class_private_members = set()
        self.class_shared_members = set()

        # Categorize members
        fields = []
        methods = []
        born_method = None

        for member in cls.members:
            if isinstance(member, VariableDecl):
                if member.value and isinstance(member.value, Closure):
                    if member.name == 'born':
                        born_method = member
                    else:
                        methods.append(member)
                    if member.is_shared:
                        self.class_shared_members.add(member.name)
                    else:
                        self.class_private_members.add(member.name)
                else:
                    fields.append(member)
                    if member.is_shared:
                        self.class_shared_members.add(member.name)
                    else:
                        self.class_private_members.add(member.name)

        # Emit fields
        for f in fields:
            prefix = "#" if not f.is_shared else ""
            if f.value is not None:
                val = self.gen_expr(f.value)
                self.emit(f"{prefix}{f.name} = {val};")
            else:
                self.emit(f"{prefix}{f.name};")

        # Emit constructor if born exists
        if born_method:
            closure = born_method.value
            # born's first param is self, skip it
            params = closure.params[1:] if closure.params and closure.params[0].name == 'self' else closure.params
            param_str = self._gen_params(params)
            has_explicit_super = self._body_has_daddy_call(closure.body)
            self.emit(f"constructor({param_str}) {{")
            self.indent_level += 1
            if cls.parent and not has_explicit_super:
                self.emit("super();")
            for s in closure.body.statements:
                self.gen_statement(s)
            self.indent_level -= 1
            self.emit("}")
        elif cls.parent:
            self.emit("constructor(...args) {")
            self.indent_level += 1
            self.emit("super(...args);")
            self.indent_level -= 1
            self.emit("}")

        # Emit methods
        for m in methods:
            closure = m.value
            has_self = closure.params and closure.params[0].name == 'self'
            is_static = not has_self

            params = closure.params[1:] if has_self else closure.params
            param_str = self._gen_params(params)

            prefix = "static " if is_static else ""
            method_prefix = "#" if not m.is_shared else ""
            self.emit(f"{prefix}{method_prefix}{m.name}({param_str}) {{")
            self.indent_level += 1
            for s in closure.body.statements:
                self.gen_statement(s)
            self.indent_level -= 1
            self.emit("}")

        self.in_class = old_class
        self.class_private_members = old_private
        self.class_shared_members = old_shared
        self.indent_level -= 1
        self.emit("}")

        if is_shared and is_module:
            self.emit(f"__exports.{name} = {name};")

    # === Expression generation ===

    def gen_expr(self, expr) -> str:
        if isinstance(expr, NumberLiteral):
            return repr(expr.value)
        if isinstance(expr, StringLiteral):
            return self._js_string(expr.value)
        if isinstance(expr, BoolLiteral):
            return "true" if expr.value else "false"
        if isinstance(expr, ArrayLiteral):
            elems = ", ".join(self.gen_expr(e) for e in expr.elements)
            return f"[{elems}]"
        if isinstance(expr, Identifier):
            return self._resolve_ident(expr.name)
        if isinstance(expr, BinaryOp):
            left = self.gen_expr(expr.left)
            right = self.gen_expr(expr.right)
            return f"({left} {expr.op} {right})"
        if isinstance(expr, UnaryOp):
            operand = self.gen_expr(expr.operand)
            return f"({expr.op}{operand})"
        if isinstance(expr, MemberAccess):
            obj = self.gen_expr(expr.object)
            member = expr.member
            # Handle daddy.method -> super.method
            if isinstance(expr.object, Identifier) and expr.object.name == 'daddy':
                return f"super.{member}"
            # Handle private member access in class context
            if self.in_class and isinstance(expr.object, Identifier) and expr.object.name == 'self':
                if member in self.class_private_members:
                    return f"this.#{member}"
                return f"this.{member}"
            return f"{obj}.{member}"
        if isinstance(expr, ModuleAccess):
            obj = self.gen_expr(expr.object)
            return f"{obj}.{expr.member}"
        if isinstance(expr, IndexAccess):
            obj = self.gen_expr(expr.object)
            idx = self.gen_expr(expr.index)
            return f"{obj}[{idx}]"
        if isinstance(expr, FunctionCall):
            # daddy(args) -> super(args)
            if isinstance(expr.callee, Identifier) and expr.callee.name == 'daddy':
                args = ", ".join(self.gen_expr(a) for a in expr.args)
                return f"super({args})"
            callee = self.gen_expr(expr.callee)
            args = ", ".join(self.gen_expr(a) for a in expr.args)
            return f"{callee}({args})"
        if isinstance(expr, Closure):
            return self.gen_closure(expr)
        if isinstance(expr, RangeExpr):
            start = self.gen_expr(expr.start)
            end = self.gen_expr(expr.end)
            return f"Array.from({{length: ({end}) - ({start})}}, (_, i) => i + ({start}))"
        if isinstance(expr, MakeoutExpr):
            callee = self.gen_expr(expr.callee)
            args = ", ".join(self.gen_expr(a) for a in expr.args)
            return f"new {callee}({args})"
        if isinstance(expr, NativeBlock):
            return self._gen_native_inline(expr.code)
        if isinstance(expr, ClassDef):
            # Inline class expression (shouldn't normally happen as top-level)
            raise CodeGenError("ClassDef should be handled by gen_variable_decl")
        raise CodeGenError(f"Unknown expression type: {type(expr).__name__}")

    def gen_closure(self, closure: Closure) -> str:
        params = self._gen_params(closure.params)
        if len(closure.body.statements) == 1 and isinstance(closure.body.statements[0], ReturnStatement):
            ret = closure.body.statements[0]
            if ret.value:
                val = self.gen_expr(ret.value)
                return f"(({params}) => {val})"

        # Multi-line closure
        lines = []
        lines.append(f"(({params}) => {{")
        old_lines = self.output_lines
        old_indent = self.indent_level
        self.output_lines = []
        self.indent_level = old_indent + 1
        for s in closure.body.statements:
            self.gen_statement(s)
        body_lines = self.output_lines
        self.output_lines = old_lines
        self.indent_level = old_indent
        lines.extend(body_lines)
        lines.append(self.indent() + "})")
        return "\n".join(lines)

    def _gen_params(self, params: list[Param]) -> str:
        parts = []
        for p in params:
            if p.is_vararg:
                parts.append(f"...{p.name}")
            else:
                parts.append(p.name)
        return ", ".join(parts)

    def _resolve_ident(self, name: str) -> str:
        if name == 'self':
            return 'this'
        return name

    def _body_has_daddy_call(self, block: Block) -> bool:
        """Check if a block contains a daddy(...) call (explicit super)."""
        for stmt in block.statements:
            if isinstance(stmt, ExpressionStatement) and self._expr_has_daddy_call(stmt.expr):
                return True
        return False

    def _expr_has_daddy_call(self, expr) -> bool:
        if isinstance(expr, FunctionCall):
            if isinstance(expr.callee, Identifier) and expr.callee.name == 'daddy':
                return True
        return False

    def _js_string(self, value: str) -> str:
        escaped = value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
        return f'"{escaped}"'

    def _gen_native_inline(self, code: str) -> str:
        # Native blocks are injected as IIFE to maintain scope
        stripped = code.strip()
        if stripped:
            return f"(() => {{{code}}})()"
        return "undefined"
